goroute 协程
------------


### 进程、线程以及并行、并发
#### 关于进程和线程
`进程`(Process)就是程序在操作系统中的一次执行过程,是系统进行资源分配和调度的基本单位,进程是一个动态的概念,是程序执行过程中分配和管理资源的基本单位,每个进程都有自己的地址空间.一个进程至少有5种基本状态:`初始态`,`执行态`,`等待状态`,`就绪状态`,`终止状态`.

`线程`是进程的一个执行实例,是程序执行的最小单元,它是比进程更小的能独立运行的基本单位  
一个进程可以创建多个线程,同一个进程中的多个线程可以并发执行,一个程序要运行至少有一个进程

#### 关于并行和并发
`并发`:多个线程同时竞争一个位置,竞争到的才可以执行,每一个时间段只有一个线程在执行.
`并行`:多个线程可以同时执行,每一个时间段可以有多个线程同时执行.
通俗的讲多线程在单核CPU上运行就是并发,多线程程序在多核心CPU上运行就是并行,如果线程数大于CPU核心数,则多线程程序在多个CPU核心上运行既有并行又有并发

### Golang中的协程`(goroutine)`以及主线程
`golang中的主线程`: (可以理解为进程或线程),在一个golang程序的主线程上可以起多个协程.Golang中多协程可以实现并行或并发.  
`协程`:可以理解为用户级线程,这是内核透明的,也就是系统并不知道有协程的存在,是完全由用户自己的程序进行调度的.Golang的一大特色就是从语言层面原生支持协程,在方法/函数前面加`go`关键字就可以创建一个协程.可以说Golang中的协程就是goroutine.

#### `多协程`与`多线程`
golang中每个`goroutine协程`默认占用内存远比`Java`,`C`的线程少.
OS线程(操作系统线程)一般都有固定的栈内存(通常为2MB),一个goroutine占用内存非常少,只有2KB左右,`多协程`切换调度开销方面远比线程要少.


### `Channel` 管道
#### `Channel` 类型
channel 是一种类型,一种引用类型.声明管道类型的格式:
```go
var 变量 chan 元素类型
var ch1 chan int  //声明一个传递整型的管道
var ch2 chan bool //声明一个传递布尔的管道
var ch3 chan []int //声明一个传递int切片的管道
```
#### 创建`channel`
声明管道后需要使用`make`函数初始化后才能使用.
```go
make(chan 元素类型,容量)
ch1 := make(chan int , 10) //创建一个能存储10个int类型的数据管道
ch2 := make(chan bool , 4) //创建一个能存储4个bool类型的数据管道
ch3 := make(chan []int , 4)//创建一个能存储4个切片类型的数据管道
```
#### `channel`操作
##### 创建/定义管道  
```go
ch := make(chan int , 3)
```
##### 1. 发送(将数据放在管道内)`<-`
```go
ch <- 3 //把3发送到ch中
```
##### 2. 接收(从管道内取出) `<-`
```go
x := <-ch //从ch中接收值并赋值给x
<-ch //从ch中接收值,忽略结果 
```
##### 3. 关闭管道 `close`
遍历`channel`时需要注意使用`for range`遍历时,管道需要使用`close`关闭
```go
close(ch)
```
而`for `遍历则不需要
##### 4. 管道阻塞 

##### 5. `for range` 遍历取值

#### 单向管道
默认情况下管道是双向的[可读、可写]
声名为只写 `chan<-`
```go
ch := make(chan<- int , 10)
```
声名为只读 `<-chan`
```go
 ch := make(<-chan int , 10)
```

#### `select`多路复用
某些场景下我们需要同时从多个通道接收数据.这个时候就可以用到golang给我们提供的`select`多路复用
```go
select{
    case: 
    case:
    default:
}
```

#### Golang并发安全和锁
##### 1. 互斥锁
互斥锁是传统并发编程中对共享资源进行访问控制的重要手段,它由标准库`sync`中的`Mutex`结构体类型表示.`sync.Mutex`类型只有两个公开的指针方法,`Lock`和`Unlock`.`Lock`锁定当前的共享资源,`Unlock`进行解锁.

##### 2. 读写互斥锁
互斥锁的本质是当一个`goroutine`访问的时候,其它`goroutine`都不能访问.这样在资源同步,避免竞争的同时也降低了程序的并发性能.程序由原来的并行执行变成了串行执行.读操作不存在竞争资源的问题,只有写才会,因此衍生了另一种锁，叫`读写锁`.
读写锁可以让多个读操作并发,同时读取,但是对写操作是完全互斥的.即:一个`goroutine`进行写操作时,其它`goroutine`既不能读也不能写.
Go中的`读写锁`由结构体类型`sync.RWMutex`表示。此类型的集合中包含2对方法:
```go
func (*RWMutex)Lock()
func (*RWMutex)Unlock()
```
另一组表示对读操作的锁定和解锁,简称`读锁定`和`读解锁`
```go
func(*RWMutex)RLock()
func(*RWMutex)RUnlock()
```

#### goroutine `Recover`解决协程中出现的`Panic`
```go
func a(){
    defer func(){
        //捕获a()函数抛出的异常
        if err := recover(); err != nil{
            fmt.Println("发生错误",err)
        }
    }
}
```
