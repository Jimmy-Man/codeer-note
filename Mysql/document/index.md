MySQL索引
========

#### 索引是什么
* 官方: 索引(Index)是帮助MySQL高效获取数据的数据。可以得到索引的本质:`索引是数据结构 `
* 你可以简单理解为`排好序的快速查找数据结构`
  + 数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用(指向)数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。
* 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储在磁盘上
* 我们平常所说的索引，如果没有特别指明，都是B树(多路搜索树,并不一定是二叉树的)结构组织的索引。其中聚集索引，次要索引，覆盖索引，复合索引，前缀索引，唯一索引默认都是使用B+树索引，统称索引。当然，除了B+树这种类型的索引之外，还有哈希索引(hash index)等。

#### 索引优势
* 类似图书馆建书目索引，提高数据检索的效率，降低数据库的IO成本
* 通过索引列对数据进行排序，降低数据排序的成本，降低了CPU的消耗

#### 索引劣势
* 实际上索引也是一张表，该表保存了主键与索引字段，并指向实体表的记录，所以索引列也是要占用空间的
* 虽然索引大大提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。因为更新表时,MySQL不仅要保存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息。

#### 索引分类
* 单值索引: `即一个索引只包含单个列，一个表可以有多个单列索引`
* 唯一索引: `索引列的值必须唯一,但允许有空值`
* 复合索引: `即一个索引包含多个列`
* 基本语法: 
  + 创建
    - `CREATE [UNIQUE] INDEX indexName ON tableName(columName(length),[columName2(length)...]);`
    - `ALTER tableName ADD [UNIQUE] INDEX [indexName] ON (columName(length))`
  + 删除
    - `DROP INDEX [indexName] ON tableName;`
  + 查看
    - `SHOW INDEX FROM tableName\G;`
  + 使用ALTER命令 有四种方式来添加数据表的索引
    - `ALTER TABLE tableName ADD PRIMARY KEY(column_list);`该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
    - `ALTER TABLE tableName ADD UNIQUE indexName (column_list);`这条语句创建索引的值必须是唯一的(除了NULL外，NULL可能会出现多次)。
    - `ALTER TABLE tableName ADD INDEX indexName (column_list);` 添加普通索引，索引值可出现多次。
    - `ALTER TABLE tableName ADD FULLTEXT indexName (column_list);`该语句指定了索引为FULLTEXT,用于全文索引。

建议一张表最多建5个索引

#### MySQL索引结构
* BTree索引
  + 初始化介绍
    一颗B+树，浅蓝色的块我们称之为一个硬盘块，可以看到每个磁盘块包含几个数据项(深蓝色所示)和指针(黄色所示),如磁盘块1包含数据项17和35,包含指针P1,P2,P3,
    P1表示小于17的磁盘块,P2表示在17和35之间的硬盘块,P3表示大于35的磁盘块。
    真实的数据存在于叶子节点，即3,5,9,10,13,15...
    非叶子节点不存储真实的数据，只存储指引搜索方向的数据项，如17,35并不真实存在于数据表中。
  + 查看过程
    如果要查找数据项29，那么首先会把磁盘块1由磁盘加载到内存，此时发生一次IO,在内存中用二分查找确定29在17和35之间，锁定磁盘块1的P2指针，内存时间因为非常短(相比磁盘的IO)可以忽略不计，通过磁盘块1的P2指针的磁盘地址把磁盘块3由磁盘加载到内存，发生第二次IO，29在26和30之间，锁定磁盘块3的P2指针，通过指针加载磁盘8到内存，发生第三次IO,同时内存中做二分查找找到29，结束查询，总计三次IO.

    真实情况是，3层B+树可以表示上百万的数据，如果上百万的数据查找只需要三次IO,性能提高将是巨大的，如果没有索引，每个数据项都要发生一次IO,那么总共需要百万次的IO,显然成本非常高
* Hash索引
* Full-text全文索引
* R-Tree索引

#### 那些情况下需要创建索引
  1. 主键自动建立唯一索引
  2. 频繁作为查询条件的字段应该创建索引
  3. 查询中与其它表关联的字段，外键关系建立索引
  4. 频繁更新的字段不适合创建索引 因为每次更新不单单是更新了记录还会更新索引
  5. Where条件里面用不到的字段不创建索引
  6. 单键/组合索引的选择问题，(在高并发下倾向于创建组合索引)
  7. 查询中排序的字段，排序字段若通过索引去访问将大大提高排序速度
  8. 查询中统计或者分组字段


#### 那些情况下不要创建索引
  1. 表记录太少
  2. 经常增删改的表 
  + 提高了查询速度，同时却会降低更新表的速度，如对表进行INSERT、UPDATE和DELETE。
  + 因为更新表时，MySQL不仅要保存数据，还要保存一下索引文件
  3. 数据重复且分布平均的表字段，因此应该只为最经常查询和最经常排序的数据列建立索引
  + 注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果

#### 性能分析
* MySQL Query Optimizer 
* MySQL常见瓶颈
  + CPU: `CPU在饱和的时候一般发生在数据装入内存或从磁盘上读取数据的时候`
  + IO: `磁盘I/O瓶颈发生在装入数据远大于内存容量的时候`
  + 服务器硬件的性能瓶颈: `top、free、iostat和vmstat来查看系统的性能状态`
* Explain
  + 是什么: `使用Explain关键字可以模拟优化器执行SQL查询语句`，从而知道Mysql是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈。
  + 能干嘛
    - 表的读取顺序
    - 数据读取操作的操作类型
    - 哪些索引可以使用
    - 哪些索引被实际使用
    - 表之间的引用
    - 每张表有多少行被优化器查询
  + 怎么用: `EXPLAIN SQL语句`
    - 包含的信息: `id|select_type|table|type|possible_key|key|key_len|ref|rows|Extra`
  + 各字段解释
    - id 
      + select查询的序列号，包含一组数字，表示查询中执行select子句操作表的顺序
      + 三种情况 
        - id相同，执行顺序由上至下
        - id不同，如果是子查询，id的序号会递增，`id值越大优先级越高，越先被执行`
        - id相同不同，同时存在[id如果相同，可以认为是一组，从上往下顺序执行，在所有组中，ID值越大，优先级越高，越先执行]
    - select_type
      + 查询类型，主要用于区别普通查询、联合查询、子查询等的复杂查询
        - 1. SIMPLE 简单的select查询，查询中不包含子查询或者UNION
        - 2. PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为PRIMARY
        - 8. SUBQUERY 在select或WHERE列表中包含了子查询
        - 4. DERIVED 在FROM列表中包含的子查询被标记为DERIVED(衍生))))MySQL会递归执行这些子查询，把结果放在临时表里
        - 5. UNION 若第二个SELECT出现在UNION之后，则被标记为UNION；若UNION包含在FROM子句的子查询中，外层SELECT将被标记为:DERVIDED
        - 6. UNION RESULT 从UNION表获取结果的SELECT

    - table
    - type 
      + 从最好到最差依次是: `system > const > eq_ref > ref > range > index > ALL`


优化规则
  1. 全值匹配(复合索引全用上)
  2. 最佳左前缀法则，如果索引
  3. 不在索引列上做任何操作(计算、函数、(自动or手动)类型转换)，会导致索引失效而转向全表扫描
  4. 存储引擎不能使用索引中范围条件右边的列
  5. 尽量使用覆盖索引(只访问索引的查询(索引列和查询列一致)),减少select* 
  6. mysql在使用不等于(!= <>)的时候无法使用索引会导致全表扫描
  7. is null ,is not null 也没法使用索引
  8. like以通配符开头('%abc...')mysql索引失效会变成全表扫描的操作
  9. 字符串不加单引号索引失效
  10. 少用or，用它来连接时索引失效