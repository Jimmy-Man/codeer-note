Redis 持久化
===========


### RDB (Redis Database)
* 是什么？
  - 在指定的时间间隔内将内存中的数据集快照写入磁盘，也就是在行话讲的Snapshot快照，它恢复时是将快照文件直接读到内存
  - Redis会单独创建(fork)一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。
  - 整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能，如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加高效。RDB的缺点是最后一次持久化后的数据可能丢失。
* Fork
  - Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据(变量、环境变量、程序读数器等)数值都和原程序一致，但是是一个全新的进程，并作为原进程的子进程
* RDB保存的是dump.rdb文件
* [配置位置](./configurate.md)
* 如何触发RDB快照
  - 配置文件中的默认的快照配置 
    + 冷拷贝后重新使用 - 可以cp dump.rdb dump_new.rdb
  - 命令save或者bgsave
    + save 只管保存 全部阻塞
    + bgsave 异步进行快照操作
    + lastsave 可以获取最后一次成功执行快照的时间
  - 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义




  --------

### AOF (Append Only File)
* 是什么：
* AOF保存的是appendonly.aof文件
* [配置位置](./configurate.md)
* AOF启动/修复/恢复
* Rewrite
* 优势
  + 每秒同步:appendfsync always 同步持久化 第次数据发生变化会立即记录到磁盘 性能较差但数据完整性比较好
  + 每修改同步: appendfsync everysec 异步操作,每秒记录 如果一秒内宕机，有数据丢失
  + 不同步: appendfsync no 从不同步
* 劣势
  + 相同数据集的数据而言aof文件要远大于rdb文件，恢复速度慢于rdb
  + Aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同
* 总结


### 总结 (Which one)
* RDB持久化方式能够在指定的时间间隔对数据进行快照存储
* AOF持久化方式记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据，AOF命令以redis协议追加保存每次写的操作到文件末尾。Redis还能对AOF文件进行后重写，使得AOF文件的体积不至于过大
* 只做缓存: 如果只希望数据在服务器运行的时候存在，也可以不使用任何持久化方式
* 同时开启2种持久化方式
  + 在这种情况下，`当redis重启的时候会优先载入AOF文件来恢复原始数据`因为通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整
  + RDB的数据不实时，同时使用两者时服务器重启也只会找AOF文件。那要不要只使用AOF呢？
  + 作者建议不要，因为RDB更适合用于备份数据库(AOF在不断变化不好备份),快速重启，而且不会有AOF可能潜在的bug，留着作为一个万一的手段。
* 性能建议
  + 因为RDB文件只用作后备的用途，建议只在Slave上持久化RDB文件，而且只要15分钟备份一次就够了，只保留save 900 1 这条规则 
  + 如果Enalbe AOF,好处是在最恶劣情况下也只会丢失不超过2秒的数据，启动脚本较简单只load自己的AOF文件就可以了。代价1是带来了持续的IO,2是AOF rewrite的最后将rewrite过程中产生的新数据写到新文件造成的阻塞几乎是不可避免的。只要硬盘许可，应该尽量减少AOF rewrite 的频率，AOF重写的基础大小默认值64M太小了，可以设到5G以上。默认超过原大小100%大小时重写可以改到适当的数值。
  + 如果不Enable AOF,仅靠Master-Slave Replication 实现高可用性也可以。能省掉一大笔IO也减少了rewrite 时带来的系统波动。代价是如果Master-Slave同时挂掉，会丢失十几分钟的数据，启动脚步也要比较2个Master/Slave中的RDB文件，载入较新的那个。微博就是选用了这种架构