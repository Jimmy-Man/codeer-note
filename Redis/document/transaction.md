Redis事务
========

是什么?
* 可以是一次执行多条命令，本质是一组命令的集合。一个事务中的所有命令都会序列化，按顺序地串行化执行而不会被其它命令插入，不许加塞

能干嘛?
* 一个队列中，一次性、顺序性、排他性的执行一系列命令

怎么玩？
* 常用命令
  + `DISCARD` 取消事务，放弃执行事务块内的所有命令
  + `EXEC` 执行所有事务块内的命令
  + `MULTI` 标记一个事务块的开始
  + `UNWATCH` 取消WATCH命令对所有key的监视
  + `WATCH key [key....]` 监视一个(或多个)key,如果在事务执行之前这个(或这些)key被其它命令所改动，那么事务将被打断
* Case1: 正常执行
* Case2: 放弃事务
* Case3: 全体连坐
* Case4: 冤头债主
* Case5: watch监控
  + 悲观锁/乐观锁/CAS(check and set)
    - 悲观锁 表锁:
    - 乐观锁 行锁
    - CAS
  + 无加塞篡改，先监控再开启MULTI
  + 有加塞篡改
  + UNWATCH
  + 一旦执行了EXEC之前加的监控锁都会被取消掉了
  + 小结
    - Watch指令，类似乐观锁，事务提交时，如果key的值已经被别的客户端修改，整个事务队列都不会被执行
    - 通过watch命令在事务执行之前监控了多个keys,倘若在watch之后有任何key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Nullmulti-bulk应答以通知调用者事务执行失败

3阶段
* 开启:以MULTIe开始一个事务
* 入队:将多个命令入列到事务中，接到这些命令并不会立即执行，而是放到等待执行的事务队列里
* 执行: 由EXEC命令触发事务

3特性
* 单独的隔离操作: `事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送过来的命令请求所打断`
* 没有隔离级别的概念:`队列中的命令没有提交之前都不会实际的被执行，因为事务提交前任何指令都不会被实际执行，也就不存在"事务内的查询要看到事务里的更新，在事务外查询不能看到"这个让人万分头痛的问题`
* 不保证原子性: redis同一个事务中如果有一条命令执行失败，其后的命令执行仍然会被执行，没有回滚